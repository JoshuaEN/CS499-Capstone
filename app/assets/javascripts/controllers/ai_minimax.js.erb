//= require controllers/ai_base
"use strict";

var AIMinimaxController = function(game, player, options) {
	BaseController.call(this, game, player);

	this.options = {
		alpha_beta: true,
		alpha_beta_gto: false,
		alpha_beta_rr: true,
		graph: false,
		record_counts: false,
		thread_minimax: false,
		recursive_deepening: false,
		max_workers: 8,
		preload_n_workers: 8,
		pause: true,
		pause_until_key: true,
		weighting_function_key: "basic",
		tiebreak_method_key: "rand",
		depth: 2,
		default_depth: 2,
		alpha_beta_rd_depths: [2,4],
		alpha_beta_rd_rr_depths: [1,3]
	}

	options = options || {};

	for(var v in options) {
		this.options[v] = options[v];
	}

	this.workers = [];


	for(var i = 0; i < this.options.preload_n_workers; i++) {
		this.workers[i] = this.create_worker();
	}

	var self = this;

	this.max = Infinity;
	this.min = -Infinity;

	this.results_check_num = 0;

	this.take_best_move = (function() {
		if(!self.game.running())
			return;

		if(!self.game.move(self.best_move))
			console.error("AI Attempted invalid move!");	
	});
};

AIMinimaxController.prototype = Object.create(AIBaseController.prototype);
AIMinimaxController.prototype.constructor = AIMinimaxController;


AIMinimaxController.prototype.your_move = function() {
	this.game.fire('player.calculating', {player: this.player});

	this.play_foward();

};

AIMinimaxController.prototype.do_move = function() {
	if(this.options.pause && this.options.pause_until_key) {
		this.game.fire('player.waitforkey', {player: this.player});
	} else {
		this.take_best_move();
	}
};

AIMinimaxController.prototype.play_foward = function() {
	var depth = (this.options.depth === undefined || this.options.depth === null ? this.options.default_depth : this.options.depth);
	this.best_move_index = null;

	this.minimax_start(this.game, depth);
};

AIMinimaxController.prototype.minimax_start = function(game, depth) {

	var minimax = this.minimax_instance();

	var minimax_result;

	if(this.options.thread_minimax) {
		var self = this;

		this.results_queue = [];
		this.results_count = 0;
		this.results_check_num += 1;
		this.graph_points = {};

		for(var i = 0; i < this.game.valid_moves.length; i++) {

			var loop_pre_res = minimax.loop_pre(i, this.game, this.depth);

			this.graph_points[i] = loop_pre_res.graph_point;


			var worker = this.workers[i%this.options.max_workers];
			if(!worker) {
				worker = this.create_worker();
				this.workers[i%this.options.max_workers] = worker;
			}

			worker.postMessage({
				game: loop_pre_res.new_game.get_internal_state(),
				options: this.options,
				player: this.player,
				index: i,
				check_num: this.results_check_num
			});
		}

	} else {
		var self = this;
		if(this.options.alpha_beta_rr) {
			if(this.options.recursive_deepening) {
				minimax_result = minimax.minimax_rr(this.game, this.options.depth, true, -Infinity, Infinity, function(game, depth, maximizing, alpha, beta) {
					return minimax.minimax_rd(game, depth, maximizing, alpha, beta, self.options.alpha_beta_rd_rr_depths);
				});
			} else {
				minimax_result = minimax.minimax_rr(this.game, this.options.depth, true, -Infinity, Infinity, function(game, depth, maximizing, alpha, beta) {
					return minimax.minimax(game, depth, maximizing, alpha, beta);
				});
			}
		} else if (this.options.recursive_deepening) {
			minimax_result = minimax.minimax_rd(this.game, this.options.depth, true, -Infinity, Infinity, this.options.alpha_beta_rd_depths);
		} else {
			minimax_result = minimax.minimax(this.game, this.options.depth, true, -Infinity, Infinity);
		}

		this.minimax_finalize(minimax_result);
	}
	return;
}


AIMinimaxController.prototype.minimax_finalize = function(res) {
	this.graph_points = {
		0: {
			board: this.game.board,
			weight: res.weight,
			subtree: res.graph_points,
			maximizing: true,
			alpha: res.alpha,
			beta: res.beta,
			ra: -Infinity,
			rb: Infinity,
			stopped: false
		}
	};

	this.valid_move_weights = res.valid_move_weights;
	this.best_move_weight = res.weight;
	this.best_move_index = res.best_move_index;

	this.best_move = this.game.valid_moves[this.best_move_index];

	this.game.fire('player.calculated', {player: this.player});

	this.do_move();
}

AIMinimaxController.prototype.draw_options = function(options_container) {
	var self = this;
	options_container.empty();

	var search_depth =
		$("<label>").text("Search Depth: ").append(
			$("<input>", {value: self.options.depth, type: "number", min: 1}).on('blur', function(){
				self.options.depth = parseInt($(this).val());
				
				if(isNaN(self.options.depth)) {
					self.options.depth = self.options.default_depth;
				}

				$(this).val(self.options.depth);

				self.recalc();	
			})
		);

	search_depth = $("<div>", {class: "form_group"}).append(search_depth);
	
	var weight_method = $("<select>");


	for(var v in Minimax_weight_functions) {
		var func = Minimax_weight_functions[v];
		weight_method.append('<option value="'+v+'">'+func.name+'</option>');
	}

	weight_method.val(this.options.weighting_function_key).on("change", function(e) {
		var func_key = $(this).val();
		self.options.weighting_function_key = func_key;
		self.recalc();
	});

	weight_method =	
		$("<label>").text("Weight Method: ").append(
			weight_method
		);

	weight_method = $("<div>", {class: "form_group"}).append(weight_method);

	var tiebreak_method = $("<select>");

	for(var v in Minimax_tiebreak_functions) {
		var func = Minimax_tiebreak_functions[v];
		tiebreak_method.append('<option value="'+v+'">'+func.name+'</option>');
	}

	tiebreak_method.val(this.options.tiebreak_method_key).on("change", function(e) {
		var func_key = $(this).val();
		self.options.tiebreak_method_key = func_key;
		self.recalc();
	});

	tiebreak_method =	
		$("<label>").text("Tie-break Method: ").append(
			tiebreak_method
		);

	tiebreak_method = $("<div>", {class: "form_group"}).append(tiebreak_method);

	var pause_until_key = $("<label>").text("Wait for Enter to Move").append(
		$("<input>", {type: "checkbox"}).prop('checked', this.options.pause_until_key).on('change', function(){
			self.options.pause_until_key = $(this).prop('checked');
			self.recalc();
		})
	);

	pause_until_key = $("<div>", {class: "form_group"}).append(pause_until_key);

	var thread_minimax = $("<label>").text("Thread Calculations").append(
		$("<input>", {type: "checkbox"}).prop('checked', this.options.thread_minimax).on('change', function(){
			self.options.thread_minimax = $(this).prop('checked');
			self.recalc();
		})
	);

	thread_minimax = $("<div>", {class: "form_group"}).append(thread_minimax);

	var alpha_beta = $("<label>").text("Alpha Beta Pruning:").append(
		$("<input>", {type: "checkbox"}).prop('checked', this.options.alpha_beta).on('change', function(){
			self.options.alpha_beta = $(this).prop('checked');
			self.recalc();
		})
	);

	alpha_beta = $("<div>", {class: "form_group"}).append(alpha_beta);

	var recursive_deepening = $("<label>").text("Recursive Deepening:").append(
		$("<input>", {type: "checkbox"}).prop('checked', this.options.recursive_deepening).on('change', function(){
			self.options.recursive_deepening = $(this).prop('checked');
			self.recalc();
		})
	);

	recursive_deepening = $("<div>", {class: "form_group"}).append(recursive_deepening);

	var alpha_beta_rr_depths =
		$("<label>").text("Recursive Deepening Depths: ").append(
			$("<input>", {value: self.options.alpha_beta_rd_depths.join(","), type: "text"}).on('blur', function(){
				var arr = $(this).val().split(",");
				
				for(var i = 0; i < arr.length; i++) {
					arr[i] = parseInt(arr[i]);
				}

				self.options.alpha_beta_rd_depths = arr;
				self.options.alpha_beta_rd_rr_depths = arr;

				self.recalc();	
			})
		);

	alpha_beta_rr_depths = $("<div>", {class: "form_group"}).append(alpha_beta_rr_depths);

	var alpha_beta_gto = $("<label>").html("Use &alpha; > &beta; (vs. &alpha; >= &beta;)").append(
		$("<input>", {type: "checkbox"}).prop('checked', this.options.alpha_beta_gto).on('change', function(){
			self.options.alpha_beta_gto = $(this).prop('checked');
			self.recalc();
		})
	);

	alpha_beta_gto = $("<div>", {class: "form_group"}).append(alpha_beta_gto);

	var alpha_beta_rr = $("<label>").html("A-B Reroot").append(
		$("<input>", {type: "checkbox"}).prop('checked', this.options.alpha_beta_rr).on('change', function(){
			self.options.alpha_beta_rr = $(this).prop('checked');
			self.recalc();
		})
	);

	alpha_beta_rr = $("<div>", {class: "form_group"}).append(alpha_beta_rr);

	var graph = $("<label>").text("Graph Search").append(
		$("<input>", {type: "checkbox"}).prop('checked', this.options.graph).on('change', function(){
			self.options.graph = $(this).prop('checked');
			self.recalc();
		})
	);

	graph = $("<div>", {class: "form_group"}).append(graph);

	var record_counts = $("<label>").text("Log Counts").append(
		$("<input>", {type: "checkbox"}).prop('checked', this.options.record_counts).on('change', function(){
			self.options.record_counts = $(this).prop('checked');
			self.recalc();
		})
	);

	record_counts = $("<div>", {class: "form_group"}).append(record_counts);

	options_container.append(search_depth, weight_method, tiebreak_method, pause_until_key, thread_minimax, alpha_beta, recursive_deepening, alpha_beta_rr_depths, alpha_beta_gto, alpha_beta_rr, graph, record_counts);
};

AIMinimaxController.prototype.draw_board = function() {
	if(this.game.game_renderer && this.valid_move_weights) {
		for(var i = 0; i < this.valid_move_weights.length; i++) {
			var index = this.game.valid_moves[i];
			var weight = this.valid_move_weights[i];

			if(index === undefined)
				continue;

			if(this.best_move_weight == weight) {
				if(this.best_move_index !== null && this.best_move_index !== undefined && this.best_move_index !== i)
					this.game.game_renderer.board_grids[index].css("background", '#FFFFB3');
				else
					this.game.game_renderer.board_grids[index].css("background", 'yellow');
			}

			this.game.game_renderer.board_grid_text[index].text(weight);
		}
	}
};

AIMinimaxController.prototype.keypress = function(ev) {
	if(this.options.pause && this.options.pause_until_key && this.best_move !== null && this.best_move !== undefined)
		this.take_best_move();
};

AIMinimaxController.prototype.reset = function(ev) {
	this.best_move = null;
	this.best_move_index = null;
	this.best_move_indexs = [];
};

AIMinimaxController.prototype.recalc = function() {
	if(this.game.active_player == this.player && this.game.running())
		this.your_move();
};

AIMinimaxController.prototype.destroy = function() {
	// Cleanup any spawned workers.
	for(var i = 0; i < this.workers.length; i++) {
		this.workers[i].terminate();
		this.workers[i] = null;
	}
};


AIMinimaxController.prototype.create_worker = function() {
	var worker = new Worker("<%= asset_path "workers/ai_minimax.js" %>");
	var self = this;
	worker.onmessage = function(event) {
		self.recieve_message(event);
	};

	return worker;
};

AIMinimaxController.prototype.minimax_instance = function() {
	return new Minimax(this.player, {
		alpha_beta: this.options.alpha_beta,
		alpha_beta_gto: this.options.alpha_beta_gto,
		record_path: (this.options.graph || this.options.record_counts),
		tiebreak: Minimax_tiebreak_functions[this.options.tiebreak_method_key].func,
		get_weight: Minimax_weight_functions[this.options.weighting_function_key].func
	});
};

AIMinimaxController.prototype.recieve_message = function(event) {
	var data = event.data;
	var maximizing = true;

	if(data.check_num != this.results_check_num)
		return;

	this.results_queue[data.index] = data.weight;

	if(this.options.graph || this.options.record_counts) {
		this.graph_points[data.index].weight = data.weight;
		this.graph_points[data.index].subtree = data.graph_points;
	}

	this.results_count += 1;

	if(this.results_count !== this.game.valid_moves.length) {
		return;
	}

	var res = this.minimax_instance().get_best(this.results_queue, true);

	res.graph_points = this.graph_points;
	this.minimax_finalize(res);
};

AIMinimaxController.prototype.toString = function() {
	// Name | Version | Reserved | Reserved | Vars
	return "AIMinimaxController|0.0|||" + 
		"alpha_beta:" + this.options.alpha_beta + ";" + 
		"alpha_beta_gto:" + this.options.alpha_beta_gto + ";" + 
		"alpha_beta_rr:" + this.options.alpha_beta_rr + ";" +
		"thread_minimax:" + this.options.thread_minimax + ";" + 
		"recursive_deepening:" + this.options.recursive_deepening + ";" +
		"max_workers:" + this.options.max_workers + ";" + 
		"weighting_function_key:" + this.options.weighting_function_key + ";" +
		"tiebreak_method_key:" + this.options.tiebreak_method_key + ";" +
		"depth:" + this.options.depth + ";" +
		"default_depth:" + this.options.default_depth + ";" +
		"alpha_beta_rd_depths:" + this.options.alpha_beta_rd_depths + ";" +
		"alpha_beta_rd_rr_depths:" + this.options.alpha_beta_rd_rr_depths + ";";
};